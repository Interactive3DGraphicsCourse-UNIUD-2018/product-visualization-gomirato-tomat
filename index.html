<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/XHTML" xml:lang="it" lang="it">
	<head>
        <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
        <link rel="stylesheet" href="index.css"/>
				<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

		<title>
			Prove GLTF
		</title>
	</head>

	<body>
        <div id="myNav" class="overlay">
            <a class="overlayTitle">Settaggi</a>
            <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

						<div class="dropdown">
							<button class="dropdown-btn">Elmo
									<i class="fa fa-caret-down"></i>
								</button>
								<div class="dropdown-container">
									<a onClick="javascript:change('oro', 'elmo');">Oro</a>
									<a onClick="javascript:change('copper', 'elmo');">Rame</a>
									<a onClick="javascript:change('carbonFiber', 'elmo');">Carbonio</a>
									<a onClick="javascript:change('metalRuined', 'elmo');">Metallo vintage</a>
									<a onClick="javascript:change('leather', 'elmo');">Pelle sintetica</a>
									<a onClick="javascript:change('camo', 'elmo');">Tattico</a>
									<a onClick="javascript:change('flower', 'elmo');">Fiore Tribale</a>
									<a onClick="javascript:change('crome', 'elmo');">Cromato</a>
									<a onClick="javascript:change('blackPlastic', 'elmo');">Plastica Nera</a>
								</div>

								<button class="dropdown-btn">Mascherina
									<i class="fa fa-caret-down"></i>
								</button>
								<div class="dropdown-container">
									<a onClick="javascript:change('oro', 'museruola');">Oro</a>
									<a onClick="javascript:change('copper', 'museruola');">Rame</a>
									<a onClick="javascript:change('carbonFiber', 'museruola');">Carbonio</a>
									<a onClick="javascript:change('metalRuined', 'museruola');">Metallo vintage</a>
									<a onClick="javascript:change('leather', 'museruola');">Pelle sintetica</a>
									<a onClick="javascript:change('camo', 'museruola');">Tattico</a>
										<a onClick="javascript:change('flower', 'museruola');">Fiore Tribale</a>
									<a onClick="javascript:change('crome', 'museruola');">Cromato</a>
								</div>

								<button class="dropdown-btn">Ornamenti
									<i class="fa fa-caret-down"></i>
								</button>
								<div class="dropdown-container">
									<a onClick="javascript:change('oro', 'disegno');">Oro</a>
									<a onClick="javascript:change('copper', 'disegno');">Rame</a>
									<a onClick="javascript:change('carbonFiber', 'disegno');">Carbonio</a>
									<a onClick="javascript:change('leather', 'disegno');">Pelle sintetica</a>
									<a onClick="javascript:change('crome', 'disegno');">Cromato</a>
									<a onClick="javascript:change('red', 'disegno');">Rosso Cromato</a>
								</div>

								<button class="dropdown-btn">Visiera
									<i class="fa fa-caret-down"></i>
								</button>
								<div class="dropdown-container">
									<a onClick="javascript:change('oro', 'visiera');">Oro</a>
									<a onClick="javascript:change('copper', 'visiera');">Rame</a>
									<a onClick="javascript:change('crome', 'visiera');">Cromato</a>
									<a onClick="javascript:change('red', 'visiera');">Rosso Cromato</a>
									<a onClick="javascript:change('blackPlastic', 'visiera');">Plastica Nera</a>
								</div>

						</div>
        </div>

        <button id="menuBtn" class="btn menuBtn" onclick="openNav()">&#9776; Settaggi </button>
        <button id="menuBtn" class="btn menuBtnOrder" onclick="">Compra ora!</button>

        <!-- ********** robot ************ -->

        <script src="lib/three.min.js"></script>
    		<script src="lib/stats.min.js"></script>
    		<script src="lib/OrbitControls.js"></script>
    		<script src='lib/dat.gui.min.js'></script>
    		<script src="lib/GLTFLoader.js"></script>


		<!-- shaders -->

		<script type="text/x-glsl" id="vertex">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec3 wPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>


		<!-- vertex shader con height map -->
		<script type="text/x-glsl" id="vertex_displ">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec3 wPosition;
		varying vec2 uVv;

		uniform sampler2D heightMap;
		uniform float scale;
		uniform vec2 textureRepeat;

		void main() {

			float displ = texture2D( heightMap, uv * textureRepeat ).x;
			displ = displ*scale;
			vec3 newPosition = position + normal * displ;

			vec4 vPos = modelViewMatrix * vec4( newPosition, 1.0 );
			vPosition = vPos.xyz;
			wPosition = (modelMatrix * vec4( newPosition, 1.0 )).xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>


    <!-- shaders per materiali uniformi e conduttivi. Vantaggio di una lettura da texture in meno(no diffuseMap) -->
		<script type="text/x-glsl" id="fragment-metalness">

			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec2 uVv;

			uniform vec3 pointLightPosition1; // in world space
      uniform vec3 pointLightPosition2; // in world space
			uniform vec3 pointLightPosition3; // in world space
			uniform vec3 clight1;
      uniform vec3 clight2;
			uniform vec3 clight3;

			uniform sampler2D baseColor;      //used as specular color
      uniform sampler2D roughnessMap;

			uniform samplerCube envMap;
      uniform samplerCube iEM;

			const float PI = 3.14159;
      const float metalness = 1.0;

      float roughness;
      vec3 cspec;
      vec3 cMat; // base color


      vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

      float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

      vec3 BRDF_Specular_GGX_Environment(vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness){
        float NdotV = saturate(dot(normal, viewDir));
        const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
        const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
        vec4 r = roughness * c0 + c1;
        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
        vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
        return cspec * AB.x + AB.y;
      }

			#extension GL_OES_standard_derivatives : enable

  		vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
  			return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
  		}

			void main() {

        // material data
        roughness = texture2D( roughnessMap, uVv ).x;
        cMat = texture2D(baseColor, uVv).rgb;
        cMat = pow( cMat, vec3(2.2));
        cspec = mix(vec3(0.0), cMat, metalness);


        vec3 v = normalize( -vPosition);
				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
        float nDotv = max(dot( n, v ),0.000001);


        // about light 1
        vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
        vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
        vec3 h1 = normalize(l1 + v);
        float nDotl1 = max(dot( n, l1 ),0.000001);
				float l1Doth1 = max(dot( l1, h1 ),0.000001);
				float nDoth1 = max(dot( n, h1 ),0.000001);
				float vDoth1 = max(dot( v, h1 ),0.000001);

        vec3 fresnel_1 = FSchlick(l1Doth1);
        vec3 BRDF1 = fresnel_1*GSmith(nDotv,nDotl1)*DGGX(nDoth1,roughness*roughness)/
					(4.0*nDotl1*nDotv);
				vec3 outRadiance1 = PI* clight1 * nDotl1 * BRDF1;



        // about light 2
        vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
        vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
        vec3 h2 = normalize(l2 + v);
        float nDotl2 = max(dot( n, l2 ),0.000001);
				float l2Doth2 = max(dot( l2, h2 ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);

        vec3 fresnel_2 = FSchlick(l2Doth2);
        vec3 BRDF2 = fresnel_2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/
          (4.0*nDotl2*nDotv);
        vec3 outRadiance2 = PI* clight2 * nDotl2 * BRDF2;


				// about light 3
        vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );
        vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);
        vec3 h3 = normalize(l3 + v);
        float nDotl3 = max(dot( n, l3 ),0.000001);
				float l3Doth3 = max(dot( l3, h3 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

        vec3 fresnel_3 = FSchlick(l3Doth3);
        vec3 BRDF3 = fresnel_3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/
          (4.0*nDotl3*nDotv);
        vec3 outRadiance3 = PI* clight3 * nDotl3 * BRDF3;

        // about environment light
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
        // negate x to account for how cubemap is displayed on background
				vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
				// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));
        vec3 outRadianceEnv = envLight * BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

        // total light
        vec3 outRadiance = outRadiance1 + outRadiance2 + outRadiance3 + outRadianceEnv;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}

		</script>


		<!-- shaders per materiali isolanti -->
		<script type="text/x-glsl" id="fragment-insulation2">

			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec2 uVv;

			uniform vec3 pointLightPosition1; // in world space
      uniform vec3 pointLightPosition2; // in world space
			uniform vec3 pointLightPosition3; // in world space
			uniform vec3 clight1;
      uniform vec3 clight2;
			uniform vec3 clight3;

			uniform sampler2D baseColor;      //used as specular color
			uniform sampler2D roughnessMap;
			uniform float metalness;

			uniform samplerCube envMap;
			uniform samplerCube iEM;

			const float PI = 3.14159;

			float roughness;
			vec3 cMat;
			vec3 cdiff;
			vec3 cspec;

			vec3 FSchlick(float lDoth){
				return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
			}

			float DGGX(float nDoth, float alfa){
				float alfa2 = alfa * alfa;
				float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
				return (alfa2 / (PI * d * d));
			}

			float G1(float dotProduct, float k){
				return (dotProduct / (dotProduct * (1.0 - k) + k));
			}

			float GSmith(float nDotv, float nDotl){
				float k = roughness * roughness;
				return (G1(nDotl, k) * G1(nDotv, k));
			}

			#extension GL_OES_standard_derivatives : enable

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			void main() {

				// material data
				roughness = texture2D( roughnessMap, uVv).x;
				cMat = texture2D(baseColor, uVv).rgb;
				cMat = pow( cMat, vec3(2.2));

				cspec = mix(vec3(0.04), cMat, roughness);
				cdiff = mix(cMat, vec3(0.0), metalness);

				vec3 v = normalize( -vPosition);
				vec3 n = normalize( vNormal );
				float nDotv = max(dot(n, v), 0.000001);

				// about environment light
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				// negate x to account for how cubemap is displayed on background
				vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
				// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));


				// about light 1
				vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
				vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
				vec3 h1 = normalize(v + l1);
				//small quantity to prevent division by 0
				float nDotl1 = max(dot(n, l1), 0.000001);
				float nDoth1 = max(dot(n, h1), 0.000001);
				float l1Doth1 = max(dot(l1, h1), 0.000001);
				float vDoth1 = max(dot(v, h1), 0.000001);

				vec3 fresnel1 = FSchlick(l1Doth1);
				vec3 BRDF_1 = (vec3(1.0)-fresnel1)*cdiff/PI + fresnel1*GSmith(nDotv,nDotl1)*DGGX(nDoth1,roughness*roughness)/
					(4.0*nDotl1*nDotv);
				vec3 outRadiance_1 = PI* clight1 * nDotl1 * BRDF_1;


				// about light 2
				vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 h2 = normalize(v + l2);
				//small quantity to prevent division by 0
				float nDotl2 = max(dot(n, l2), 0.000001);
				float nDoth2 = max(dot(n, h2), 0.000001);
				float l2Doth2 = max(dot(l2, h2), 0.000001);
				float vDoth2 = max(dot(v, h2), 0.000001);

				vec3 fresnel2 = FSchlick(l2Doth2);
				vec3 BRDF_2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/
					(4.0*nDotl2*nDotv);
				vec3 outRadiance_2 = PI* clight2 * nDotl2 * BRDF_2;

				// about light 3
				vec4 lPosition3 = viewMatrix * vec4(pointLightPosition3, 1.0);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);
				vec3 h3 = normalize(v + l3);
				//small quantity to prevent division by 0
				float nDotl3 = max(dot(n, l3), 0.000001);
				float nDoth3 = max(dot(n, h3), 0.000001);
				float l3Doth3 = max(dot(l3, h3), 0.000001);
				float vDoth3 = max(dot(v, h3), 0.000001);

				vec3 fresnel3 = FSchlick(l3Doth3);
				vec3 BRDF_3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/
					(4.0*nDotl3*nDotv);
				vec3 outRadiance_3 = PI* clight3 * nDotl3 * BRDF_3;

				vec3 outRadiance = (envLight * cspec * cdiff) +  outRadiance_1 +  outRadiance_2 + outRadiance_3;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}

		</script>



		<!-- shaders per materiali isolanti -->
		<script type="text/x-glsl" id="fragment-insulation">

			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec2 uVv;

			uniform vec2 normalScale;
			uniform vec3 pointLightPosition1; // in world space
      uniform vec3 pointLightPosition2; // in world space
			uniform vec3 pointLightPosition3; // in world space
			uniform vec3 clight1;
      uniform vec3 clight2;
			uniform vec3 clight3;

			uniform sampler2D baseColor;      //used as specular color
      uniform sampler2D roughnessMap;
			uniform sampler2D metalnessMap;
			uniform sampler2D normalMap;
			uniform sampler2D aoMap;
			uniform vec2 textureRepeat;

			uniform samplerCube envMap;
      uniform samplerCube iEM;

			const float PI = 3.14159;

      float roughness;
			float metalness;
			float ao;
			vec3 cMat;
      vec3 cdiff;
			vec3 cspec;

			vec3 FSchlick(float lDoth){
				return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
			}

			float DGGX(float nDoth, float alfa){
				float alfa2 = alfa * alfa;
				float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
				return (alfa2 / (PI * d * d));
			}

			float G1(float dotProduct, float k){
				return (dotProduct / (dotProduct * (1.0 - k) + k));
			}

			float GSmith(float nDotv, float nDotl){
				float k = roughness * roughness;
				return (G1(nDotl, k) * G1(nDotv, k));
			}

    	#extension GL_OES_standard_derivatives : enable

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( uVv.st );
				vec2 st1 = dFdy( uVv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, uVv * textureRepeat ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );

			}

  		vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
  			return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
  		}

			void main() {

        // material data
        roughness = texture2D( roughnessMap, uVv * textureRepeat ).x;
				metalness = texture2D( metalnessMap, uVv * textureRepeat ).x;
				ao = texture2D( aoMap, uVv * textureRepeat ).x;
        cMat = texture2D(baseColor, uVv * textureRepeat).rgb;
        cMat = pow( cMat, vec3(2.2));

				cspec = mix(vec3(0.04), cMat, metalness)*ao;
				cdiff = mix(cMat, vec3(0.0), metalness)*ao;

        vec3 v = normalize( -vPosition);
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				float nDotv = max(dot(n, v), 0.000001);

				// about environment light
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				// negate x to account for how cubemap is displayed on background
				vec3 envLight = textureCube( iEM, vec3(-r.x, r.yz)).rgb;
				// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));


        // about light 1
        vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
				vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
				vec3 h1 = normalize(v + l1);
				//small quantity to prevent division by 0
				float nDotl1 = max(dot(n, l1), 0.000001);
				float nDoth1 = max(dot(n, h1), 0.000001);
				float l1Doth1 = max(dot(l1, h1), 0.000001);
				float vDoth1 = max(dot(v, h1), 0.000001);

				vec3 fresnel1 = FSchlick(l1Doth1);
				vec3 BRDF_1 = (vec3(1.0)-fresnel1)*cdiff/PI + fresnel1*GSmith(nDotv,nDotl1)*DGGX(nDoth1,roughness*roughness)/
					(4.0*nDotl1*nDotv);
				vec3 outRadiance_1 = PI* clight1 * nDotl1 * BRDF_1;


        // about light 2
				vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 h2 = normalize(v + l2);
				//small quantity to prevent division by 0
				float nDotl2 = max(dot(n, l2), 0.000001);
				float nDoth2 = max(dot(n, h2), 0.000001);
				float l2Doth2 = max(dot(l2, h2), 0.000001);
				float vDoth2 = max(dot(v, h2), 0.000001);

				vec3 fresnel2 = FSchlick(l2Doth2);
				vec3 BRDF_2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/
					(4.0*nDotl2*nDotv);
				vec3 outRadiance_2 = PI* clight2 * nDotl2 * BRDF_2;


				// about light 3
				vec4 lPosition3 = viewMatrix * vec4(pointLightPosition3, 1.0);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);
				vec3 h3 = normalize(v + l3);
				//small quantity to prevent division by 0
				float nDotl3 = max(dot(n, l3), 0.000001);
				float nDoth3 = max(dot(n, h3), 0.000001);
				float l3Doth3 = max(dot(l3, h3), 0.000001);
				float vDoth3 = max(dot(v, h3), 0.000001);

				vec3 fresnel3 = FSchlick(l3Doth3);
				vec3 BRDF_3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/
					(4.0*nDotl3*nDotv);
				vec3 outRadiance_3 = PI* clight3 * nDotl3 * BRDF_3;

				vec3 outRadiance = (envLight * cdiff) +  outRadiance_1 +  outRadiance_2 + outRadiance_3;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}

		</script>

		<!-- shaders per materiali isolanti -->
		<script type="text/x-glsl" id="fragment-metalRuined">

			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec2 uVv;

			uniform vec2 normalScale;
			uniform vec3 pointLightPosition1; // in world space
      uniform vec3 pointLightPosition2; // in world space
			uniform vec3 pointLightPosition3; // in world space
			uniform vec3 clight1;
      uniform vec3 clight2;
			uniform vec3 clight3;

			uniform sampler2D baseColor;      //used as specular color
      uniform sampler2D roughnessMap;
			uniform sampler2D diffuseMap;
			uniform sampler2D metalnessMap;
			uniform sampler2D normalMap;
			uniform sampler2D aoMap;
			uniform vec2 textureRepeat;

			uniform samplerCube envMap;
      uniform samplerCube iEM;

			const float PI = 3.14159;

      float roughness;
			float metalness;
			float diffuseFactor;
			float ao;
			vec3 cMat;
      vec3 cdiff;
			vec3 cspec;

			vec3 FSchlick(float lDoth){
				return (cspec + (vec3(1.0) - cspec) * pow(1.0 - lDoth, 0.5));
			}

			float DGGX(float nDoth, float alfa){
				float alfa2 = alfa * alfa;
				float d = nDoth * nDoth * (alfa2 - 1.0) + 1.0;
				return (alfa2 / (PI * d * d));
			}

			float G1(float dotProduct, float k){
				return (dotProduct / (dotProduct * (1.0 - k) + k));
			}

			float GSmith(float nDotv, float nDotl){
				float k = roughness * roughness;
				return (G1(nDotl, k) * G1(nDotv, k));
			}

    	#extension GL_OES_standard_derivatives : enable

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( uVv.st );
				vec2 st1 = dFdy( uVv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, uVv * textureRepeat ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );

			}

  		vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
  			return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
  		}

			void main() {

        // material data
        roughness = texture2D( roughnessMap, uVv * textureRepeat ).x;
				metalness = texture2D( metalnessMap, uVv * textureRepeat ).x;
				diffuseFactor = texture2D( diffuseMap, uVv * textureRepeat ).x;
				ao = texture2D( aoMap, uVv * textureRepeat ).x;
        cMat = texture2D(baseColor, uVv * textureRepeat).rgb;
        cMat = pow( cMat, vec3(2.2));

				cspec = mix(cMat, vec3(0.04), metalness)*ao;
				cdiff = mix(vec3(0.0), cMat, roughness)*ao*diffuseFactor;

        vec3 v = normalize( -vPosition);
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				float nDotv = max(dot(n, v), 0.000001);

				// about environment light
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				// negate x to account for how cubemap is displayed on background
				vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
				// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));


        // about light 1
        vec4 lPosition1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
				vec3 l1 = normalize(lPosition1.xyz - vPosition.xyz);
				vec3 h1 = normalize(v + l1);
				//small quantity to prevent division by 0
				float nDotl1 = max(dot(n, l1), 0.000001);
				float nDoth1 = max(dot(n, h1), 0.000001);
				float l1Doth1 = max(dot(l1, h1), 0.000001);
				float vDoth1 = max(dot(v, h1), 0.000001);

				vec3 fresnel1 = FSchlick(l1Doth1);
				vec3 BRDF_1 = (vec3(1.0)-fresnel1)*cdiff/PI + fresnel1*GSmith(nDotv,nDotl1)*DGGX(nDoth1,roughness*roughness)/
					(4.0*nDotl1*nDotv);
				vec3 outRadiance_1 = PI* clight1 * nDotl1 * BRDF_1;


        // about light 2
				vec4 lPosition2 = viewMatrix * vec4(pointLightPosition2, 1.0);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 h2 = normalize(v + l2);
				//small quantity to prevent division by 0
				float nDotl2 = max(dot(n, l2), 0.000001);
				float nDoth2 = max(dot(n, h2), 0.000001);
				float l2Doth2 = max(dot(l2, h2), 0.000001);
				float vDoth2 = max(dot(v, h2), 0.000001);

				vec3 fresnel2 = FSchlick(l2Doth2);
				vec3 BRDF_2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/
					(4.0*nDotl2*nDotv);
				vec3 outRadiance_2 = PI* clight2 * nDotl2 * BRDF_2;

				// about light 3
				vec4 lPosition3 = viewMatrix * vec4(pointLightPosition3, 1.0);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);
				vec3 h3 = normalize(v + l3);
				//small quantity to prevent division by 0
				float nDotl3 = max(dot(n, l3), 0.000001);
				float nDoth3 = max(dot(n, h3), 0.000001);
				float l3Doth3 = max(dot(l3, h3), 0.000001);
				float vDoth3 = max(dot(v, h3), 0.000001);

				vec3 fresnel3 = FSchlick(l3Doth3);
				vec3 BRDF_3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/
					(4.0*nDotl3*nDotv);
				vec3 outRadiance_3 = PI* clight3 * nDotl3 * BRDF_3;

				vec3 outRadiance = (envLight * cdiff) +  outRadiance_1 +  outRadiance_2 + outRadiance_3;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}

		</script>


		<!-- three.js code -->

		<script>

			var renderer = new THREE.WebGLRenderer( { antialias: true } );
			var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
			var scene = new THREE.Scene();
      var controls = new THREE.OrbitControls( camera, renderer.domElement );
      //LOADER MODELLO GLTF
      var loader = new THREE.GLTFLoader();
      //Array di 8 stringhe contenenti i nomi dei figli dell'oggetto GLTF
      var objNames = ["disegno","disegno","elmo","museruola","visiera","elmo","elmo"];


			// loaders cubemap/envMap/texture
			var cubeMapLoader = new THREE.CubeTextureLoader();
      var tLoader = new THREE.TextureLoader();

			// load irradiance map
			cubeMapLoader.setPath( 'irradianceMap/vanc/' );
			var irradianceMap = cubeMapLoader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );
      // Load background cube map
      cubeMapLoader.setPath( 'envMap/vanc/' );
			var envMap = cubeMapLoader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg'
			] );
      scene.background = envMap;
			envMap.minFilter = THREE.LinearMipMapLinearFilter;



      //********* MATERIALI **************************

      vs = document.getElementById("vertex").textContent;
			vs_displ = document.getElementById("vertex_displ").textContent;
			fs_metal = document.getElementById("fragment-metalness").textContent;
      fs_ins = document.getElementById("fragment-insulation").textContent;
			fs_ins2 = document.getElementById("fragment-insulation2").textContent;
			fs_metalRuined = document.getElementById("fragment-metalRuined").textContent;

      //DEFINIZIONE MATERIALI PERSONALIZZATI
      materialExtensions = {
        derivatives: true, //set to use derivatives
        shaderTextureLOD: true //set to use shader texture LOD
      }



      // carbonio
      var carbPath = "textures/carbonFiber/new/";

      var fiberUniforms = {
        baseColor: {type: "t", value: loadTexture(carbPath + "baseColor.png")},
        normalMap: {type: "t", value: loadTexture(carbPath + "normalMap.png")},
        roughnessMap: {type: "t", value: loadTexture(carbPath + "roughness.png")},
				metalnessMap: {type: "t", value: loadTexture(carbPath + "metallic.png")},
				normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
				textureRepeat: {type: "v2", value: new THREE.Vector2(8,8)},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap},
				aoMap: {type: "t", value: loadTexture(carbPath + "aoMap.png")}
      }

      var carbonFiber = new THREE.ShaderMaterial({uniforms: fiberUniforms, vertexShader: vs, fragmentShader: fs_ins, extensions: materialExtensions});



			// pelle sintetica
      var leatherPath = "textures/Leather/";

      var leatherUniforms = {
        baseColor: {type: "t", value: loadTexture(leatherPath + "baseColor.jpg")},
        normalMap: {type: "t", value: loadTexture(leatherPath + "normalMap.jpg")},
        roughnessMap: {type: "t", value: loadTexture(leatherPath + "roughness.jpg")},
				metalnessMap: {type: "t", value: loadTexture(leatherPath + "metallic.jpg")},
				normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
				textureRepeat: {type: "v2", value: new THREE.Vector2(8,8)},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -60)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap},
				aoMap: {type: "t", value: loadTexture(leatherPath + "aoMap.jpg")}
      }

      var leather = new THREE.ShaderMaterial({uniforms: leatherUniforms, vertexShader: vs, fragmentShader: fs_ins, extensions: materialExtensions});



      // rame
      var coPath = 'textures/copper/';
      var copperUniforms = {
        baseColor: {type: "t", value: loadTexture(coPath + "baseColor.png")},
        roughnessMap: {type: "t", value: loadTexture(coPath + "roughness.png")},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}
      }

      var copper = new THREE.ShaderMaterial({uniforms: copperUniforms, vertexShader: vs, fragmentShader: fs_metal, extensions: materialExtensions});

			// cromato
			var crPath = 'textures/cromo/';
			var cromeUniforms = {
				baseColor: {type: "t", value: loadTexture(crPath + "baseColor.png")},
        roughnessMap: {type: "t", value: loadTexture(crPath + "roughness.png")},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}
			}

			var crome = new THREE.ShaderMaterial({uniforms: cromeUniforms, vertexShader: vs, fragmentShader: fs_metal, extensions: materialExtensions});


			// rosso cromato
			var crPath = 'textures/cromo/';
			var redUniforms = {
				baseColor: {type: "t", value: loadTexture(crPath + "red.png")},
        roughnessMap: {type: "t", value: loadTexture(crPath + "roughness.png")},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}
			}

			var red = new THREE.ShaderMaterial({uniforms: redUniforms, vertexShader: vs, fragmentShader: fs_metal, extensions: materialExtensions});


	    // oro
	    var gPath = 'textures/gold/';
	    var goldUniforms = {
	      baseColor: {type: "t", value: loadTexture(gPath + "baseColor.jpg")},
	      roughnessMap: {type: "t", value: loadTexture(gPath + "roughness.jpg")},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
	      envMap: {type: "t", value: envMap},
	      iEM: {type: "t", value: irradianceMap}
	    }

	    var gold = new THREE.ShaderMaterial({uniforms: goldUniforms, vertexShader: vs, fragmentShader: fs_metal, extensions: materialExtensions});


			// metallo rovinato
	    var metalPath = 'textures/metal/new/';
	    var metalUniforms = {
				baseColor: {type: "t", value: loadTexture(metalPath + "baseColor.png")},
        normalMap: {type: "t", value: loadTexture(metalPath + "normalMap.png")},
				diffuseMap: {type: "t", value: loadTexture(metalPath + "diffuseMap.png")},
        roughnessMap: {type: "t", value: loadTexture(metalPath + "roughness.png")},
				metalnessMap: {type: "t", value: loadTexture(metalPath + "metallic.png")},
				heightMap: {type: "t", value: loadTexture(metalPath + "heightMap.png")},
				aoMap: {type: "t", value: loadTexture(metalPath + "aoMap.png")},
				scale: {type: "f", value: 0.1},
				normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
				textureRepeat: {type: "v2", value: new THREE.Vector2(5,5)},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}
	    }

	    var ruinedMetal = new THREE.ShaderMaterial({uniforms: metalUniforms, vertexShader: vs_displ, fragmentShader: fs_metalRuined, extensions: materialExtensions});


			// tessuto mimetico
      var camoPath = "textures/camo/";

      var camoUniforms = {
        baseColor: {type: "t", value: loadTexture(camoPath + "baseColor.png")},
        normalMap: {type: "t", value: loadTexture(camoPath + "normalMap.jpg")},
        roughnessMap: {type: "t", value: loadTexture(camoPath + "roughnessMap.jpg")},
				metalnessMap: {type: "t", value: loadTexture(camoPath + "metallic.jpg")},
				normalScale: {type: "v2", value: new THREE.Vector2(2,2)},
				textureRepeat: {type: "v2", value: new THREE.Vector2(3,3)},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap},
				aoMap: {type: "t", value: loadTexture(camoPath + "roughnessMap.jpg")}
      }

      var camo = new THREE.ShaderMaterial({uniforms: camoUniforms, vertexShader: vs, fragmentShader: fs_ins, extensions: materialExtensions});


			// floreale
      var floUniforms = {
        baseColor: {type: "t", value: loadTexture(camoPath + "flw2.jpg")},
        normalMap: {type: "t", value: loadTexture(camoPath + "normalMap.jpg")},
        roughnessMap: {type: "t", value: loadTexture(camoPath + "roughnessMap.jpg")},
				metalnessMap: {type: "t", value: loadTexture(camoPath + "metallic.jpg")},
				normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
				textureRepeat: {type: "v2", value: new THREE.Vector2(4,4)},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap},
				aoMap: {type: "t", value: loadTexture(camoPath + "roughnessMap.jpg")}
      }

      var flower = new THREE.ShaderMaterial({uniforms: floUniforms, vertexShader: vs, fragmentShader: fs_ins, extensions: materialExtensions});

			// plastica nera
			var plasticUniforms = {
				baseColor: {type: "t", value: loadTexture(camoPath + "plastic.jpg")},
        roughnessMap: {type: "t", value: loadTexture(camoPath + "plastic.jpg")},
				metalnes: {type: "f", value: 0.0},
				pointLightPosition1: {type: "v3", value: new THREE.Vector3(20, 20, -20)},
	      pointLightPosition2: {type: "v3", value: new THREE.Vector3(-20, 20, 20)},
				pointLightPosition3: {type: "v3", value: new THREE.Vector3(-20, 0, -20)},
	      clight1: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
	      clight2: {type: "v3", value: new THREE.Vector3(0.1,0.1,0.1)},
				clight3: {type: "v3", value: new THREE.Vector3(0.01,0.01,0.01)},
        envMap: {type: "t", value: envMap},
        iEM: {type: "t", value: irradianceMap}
      }

      var blackPlastic = new THREE.ShaderMaterial({uniforms: plasticUniforms, vertexShader: vs, fragmentShader: fs_ins2, extensions: materialExtensions});


			function loadTexture(file) {
					var texture = tLoader.load( file , function ( texture ) {
						texture.minFilter = THREE.LinearMipMapLinearFilter;
						texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
						texture.offset.set(0, 0);
						texture.needsUpdate = true;
						render();
					} )
					return texture;
			}

      function retriveMaterial(matName){

        switch(matName){
          case 'copper': return copper;
          case 'oro': return gold;
          case 'metalRuined': return ruinedMetal;
					case 'carbonFiber': return carbonFiber;
					case 'camo': return camo;
					case 'leather': return leather;
					case 'crome': return crome;
					case 'red': return red;
					case 'flower': return flower;
					case 'blackPlastic': return blackPlastic;
          default: return gold;
        }
      }

      function change(mat, part){
        applyMaterial(retriveMaterial(mat), part);
      }

      function applyMaterial(material, name){

        //Un po di debugging
        console.log("scene length: " + scene.children.length);

        for(let i = 0; i < scene.children.length; i++){
          console.log("figlio scena n.ro: " + i);
          console.log( scene.children[i]);
        }


        let b = 0;
        let obj = scene.children[1];    //indicizzo il modello gltf  -- ?? scene.children - 1
        console.log("Ho caricato: " + obj);

        if(obj == undefined){
          return;
        }

        console.log("Entro nel While");
        while(!(obj.children.length == 6)){ //finchÃ¨ non arrivo al nodo radice delle mesh
          console.log("passo n.ro: " + b);
          obj = obj.children[0];
          b++;
        }
        for(let i = 0; i < obj.children.length; i++){

					console.log("for n.ro: " + i);
					for(let j = 0; j < obj.children[i].children.length; j++){
	          if(obj.children[i].children[j].name == name){ //accedo al nipote, che contiene la mesh
	            console.log("trovato figlio!!");
	            obj.children[i].children[j].material = material;
	          }else{
							console.log("figlio analizzato: " + obj.children[i].children[j].name );
						}
					}
        }
        render();
      }

      function loadModel(){

        loader.load('kylo_rens_helmet_realistic/scene.gltf', function(gltf){
          let i = 0;
          gltf.scene.traverse( function ( child ) {
            if(child.isMesh){

                child.name = objNames[i];
                console.log(child.name);
                if(child.name == 'museruola'){
                  child.material = leather;
								}else if(child.name == 'elmo'){
									child.material = ruinedMetal;
								}else if(child.name == 'disegno'){
									child.material = crome;
                }else{
                  child.material = red;
                }
                i++;
            }
          });
          scene.add(gltf.scene);
					gltf.scene.position.set(-26,-4,0);
					gltf.scene.scale.multiplyScalar(0.5);
        });

      }


			function init() {

        loadModel();

				renderer.setClearColor( 0xf0f0f0 );

				camera.position.set( 0, 0, 15 );
				camera.lookAt(0,0,0);

				scene.add(camera);

        controls.minDistance = 5;
				controls.maxDistance = 30;
				controls.enablePan = false; //TODO: mettere false alla fine
				controls.update();

				document.body.appendChild( renderer.domElement );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				window.addEventListener( 'resize', onResize, false );

      }


			function onResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = ( window.innerWidth / window.innerHeight );
				camera.updateProjectionMatrix();

			}


			function update() {
				requestAnimationFrame( update );
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

      init();
      update();
      render();

  // *****************************


  function openNav() {
      document.getElementById("myNav").style.width = "320px";
      document.getElementById("menuBtn").style.visibility = "hidden";
  }

  function closeNav() {
      document.getElementById("myNav").style.width = "0%";
      document.getElementById("menuBtn").style.visibility = "visible";
  }

  function changeMaterial(index){
      if(selected !== index){
          document.getElementById(index).classList.add("btnDisabled");
          document.getElementById(selected).classList.remove("btnDisabled");

          selected = index;
          checkLoaded(selected);

          closeNav();
      }
  }


  var dropdown = document.getElementsByClassName("dropdown-btn");
  var i;

  for (i = 0; i < dropdown.length; i++) {
    dropdown[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var dropdownContent = this.nextElementSibling;
      if (dropdownContent.style.display === "block") {
        dropdownContent.style.display = "none";
      } else {
        dropdownContent.style.display = "block";
      }
    });
  }


        </script>
	</body>
</html>
